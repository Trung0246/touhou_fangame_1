//How to include this file: wait until #TouhouDanmakufu[Stage] made, then include this script as #System["script/main/script/system/Gui.dnh"]
#include "script/main/script/lib/Utils.dnh"

let dir = GetModuleDirectory() ~ "script/main/img/system/";
let guiPath = dir ~ "front00.png";
let digitPath = dir ~ "ascii.png";

@Initialize {
	InitFrame();
	InitLine();
	UpdateHiScore();
	UpdateScore();
	UpdatePlayerLife();
	UpdatePlayerSpell();
	UpdatePower();
	UpdatePoint(); //Blue drop bonus //144 * 24 for phantasm, ... 304 x 46 for disable
	UpdateGraze();
	UpdateBossLife();
	UpdateBossTimer();
	//UpdateBossXPos();
	UpdateCurrentFpsAndMs();
	UpdateReplayFps();
}

@MainLoop {
	yield;
}

@Event {
	alternative (GetEventType())
	case (EV_START_BOSS_STEP) {
		let tempObj = GetEnemyBossObjectID();
		ascent (i in 0..length(tempObj)) {
			UpdateBossXPos(tempObj[i]);
		}
		UpdateBossTimer;
	}
	case (EV_END_BOSS_STEP) {
		
	}
	case(EV_START_BOSS_SPELL) {
		/*let path = dir ~ "Default_System_MagicCircle.txt";
		let id = LoadScript(path);
		StartScript(id);*/
	}
	case(EV_GAIN_SPELL) {
		let objScene = GetEnemyBossSceneObjectID();
		let score = ObjEnemyBossScene_GetInfo(objScene, INFO_SPELL_SCORE);
		//TGainSpell(score);
	}
	case (EV_PLAYER_SPELL) {
		let tempSpell = GetCommonData("player_spell", 0);
		if (tempSpell > 0) {
			SetCommonData("player_spell", tempSpell - 1);
		}
	}
	case (EV_PLAYER_SHOOTDOWN) {
		let tempLife = GetCommonData("player_life", 0);
		if (tempLife > 0) {
			SetCommonData("player_life", tempLife - 1);
		}
	}
}

task InitFrame {
	//328, 703 //right
	//47, 703 //left
	//563, 24 //top
	//563, 23 //bottom

	let frame = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
  ObjPrim_SetTexture(frame,guiPath);
  Obj_SetRenderPriority(frame,0.1);
  ObjRender_SetBlendType(frame, 0); //TO hide tiny black line
  //left
  ObjSpriteList2D_SetSourceRect(frame,0,0,47,703);
  ObjSpriteList2D_SetDestRect(frame,0,0,32,480);
  ObjSpriteList2D_AddVertex(frame);
  //top
  ObjSpriteList2D_SetSourceRect(frame,0,703,562,727);
  ObjSpriteList2D_SetDestRect(frame,32,0,416,16);
  ObjSpriteList2D_AddVertex(frame);
  //bottom
  ObjSpriteList2D_SetSourceRect(frame,0,726,562,750);
  ObjSpriteList2D_SetDestRect(frame,32,464,416,480);
  ObjSpriteList2D_AddVertex(frame);
  //right
  ObjSpriteList2D_SetSourceRect(frame,47,0,375,703);
  ObjSpriteList2D_SetDestRect(frame,416,0,640,480);
  ObjSpriteList2D_AddVertex(frame);
}
task InitLine {
	//7 lines
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, guiPath);
	Obj_SetRenderPriority(obj, 0.1);

	let arrayXY = [
		640 - 212.5, 40 + 18, //Hiscore
		640 - 212.5, 62.5 + 18, //Score, 212.5
		640 - 212.5, 94 + 30, //Life, 211
		640 - 212.5, 130 + 30, //Spell, 212.5 - 10
		640 - 212.5 + 45, 225 - 46 + 19, //Power, 200
		640 - 212.5 + 45, 225 - 21.5 + 17, //Point, 200
		640 - 212.5 + 45, 225 + 18 //Graze, 220
	];
	let arrayTexture = [
		130, 130, 130, 200,
		255, 255, 255, 200,
		234, 145, 227, 200,
		60, 224, 115, 200,
		219, 127, 70, 170,
		22, 181, 255, 170,
		210, 210, 210, 170
	];
	ascent (i in 0..7) {
		let count = i * 2;
		ObjSpriteList2D_SetSourceRect(obj, 680, 726, 749, 749);
		ObjSpriteList2D_SetDestRect(obj, arrayXY[i * 2], arrayXY[i * 2 + 1], arrayXY[i * 2] + arrayTexture[i * 4 + 3], arrayXY[i * 2 + 1] + 2);
		ObjRender_SetColor(obj, arrayTexture[i * 4], arrayTexture[i * 4 + 1], arrayTexture[i * 4 + 2]);
		ObjRender_SetAlpha(obj, 300);
		ObjSpriteList2D_AddVertex(obj);
	}
}
task UpdateHiScore {
	let objScore = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objScore, guiPath);
	Obj_SetRenderPriority(objScore, 0.1);
	ObjSprite2D_SetSourceRect(objScore, 375 + 1, 26 * 0 + 1, 375 + 104, (26 * 1) - 1); //Plus 1 at 375 because some weird problem that a black line appear
	ObjSprite2D_SetDestRect(objScore, 0, 0, 104, 26);
	ObjRender_SetScaleX(objScore, 0.75);
	ObjRender_SetScaleY(objScore, 0.75);
	ObjRender_SetX(objScore, 640 - 220);
	ObjRender_SetY(objScore, 40);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 40 + 2);
	ObjRender_SetColor(obj, 180, 180, 180);

	while (true) {
		let number = 2147483647; //Temporary, will try to get high score here
		number = min(number, 2147483647); //2147483647, cap of int, rounded 2000000000
		let listNum = NumberToArray(number, true);
		let commaCount = 0;

		ObjSpriteList2D_ClearVertexCount(obj);
		descent (i in 0 .. length(listNum)) {
			let num = listNum[i];
			ObjRender_SetX(obj, 640 - 20 - (length(listNum) - 1 - i) * 12);
			if (ToString(num) == ",") {
				ObjSpriteList2D_SetSourceRect(obj, 224, 144 + 1, 239, 159 + 1);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0 + 5, 16 + commaCount * 5, 16 + 5);
				ObjRender_SetX(obj, ObjRender_GetX(obj) + 6);
				commaCount ++;
			} else {
				ObjSpriteList2D_SetSourceRect(obj, num * 16, 144, (num + 1) * 16, 144 + 16);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0, 16 + commaCount * 5, 16);
			}
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}
task UpdateScore {
	let objScore = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objScore, guiPath);
	Obj_SetRenderPriority(objScore, 0.1);
	ObjSprite2D_SetSourceRect(objScore, 375 + 1, 26 * 1, 375 + 104, (26 * 2) - 1); //Plus 1 at 375 because some weird problem that a black line appear
	ObjSprite2D_SetDestRect(objScore, 0, 0, 104, 26);
	ObjRender_SetScaleX(objScore, 0.75);
	ObjRender_SetScaleY(objScore, 0.75);
	ObjRender_SetX(objScore, 640 - 220);
	ObjRender_SetY(objScore, 62.5);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 62 + 2);

	let scoreLeft = 0;

	while (true) {
		let tempChange = GetCommonData("player_score_change", 0);
		if (tempChange > 0) {
			scoreLeft += tempChange;
			SetCommonData("player_score_change", 0);
		}
		if (scoreLeft > 10) {
			let scoreChange = floor(scoreLeft / GetCommonData("player_score_speed", 1));
			AddScore(scoreChange);
			scoreLeft -= scoreChange; 
		} else if (scoreLeft > 0 && scoreLeft <= 10) {
			AddScore(scoreLeft);
			scoreLeft = 0;
		}

		let maxScore = GetCommonData("player_score_max", 2147483647);
		let number = GetScore();
		if (number > maxScore) {
			AddScore(-(number - maxScore));
			number = GetScore();
		}
		number = min(number, maxScore);
		let listNum = NumberToArray(number, true);
		let commaCount = 0;

		ObjSpriteList2D_ClearVertexCount(obj);
		descent (i in 0 .. length(listNum)) {
			let num = listNum[i];
			ObjRender_SetX(obj, 640 - 20 - (length(listNum) - 1 - i) * 12);
			if (ToString(num) == ",") {
				ObjSpriteList2D_SetSourceRect(obj, 224, 144 + 1, 239, 159 + 1);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0 + 5, 16 + commaCount * 5, 16 + 5);
				ObjRender_SetX(obj, ObjRender_GetX(obj) + 6);
				commaCount ++;
			} else {
				ObjSpriteList2D_SetSourceRect(obj, num * 16, 144, (num + 1) * 16, 144 + 16);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0, 16 + commaCount * 5, 16);
			}
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}
task UpdateGraze {
	let objGraze = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objGraze, guiPath);
	Obj_SetRenderPriority(objGraze, 0.1);
	ObjSprite2D_SetSourceRect(objGraze, 479, 26 * 1, 479 + 127, (26 * 2) - 1);
	ObjSprite2D_SetDestRect(objGraze, 0, 0, 128, 26);
	ObjRender_SetScaleX(objGraze, 0.75);
	ObjRender_SetScaleY(objGraze, 0.75);
	ObjRender_SetX(objGraze, 640 - 200);
	ObjRender_SetY(objGraze, 225);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 225 + 2);

	while (true) {
		let grazeMax = GetCommonData("player_graze_max", 0);
		let number = GetGraze();
		if (number > grazeMax) {
			AddGraze(-(number - grazeMax));
			number = GetGraze();
		}
		number = min(number, grazeMax);
		let listNum = NumberToArray(number, true);
		let commaCount = 0;

		ObjSpriteList2D_ClearVertexCount(obj);
		descent (i in 0 .. length(listNum)) {
			let num = listNum[i];
			ObjRender_SetX(obj, 640 - 20 - (length(listNum) - 1 - i) * 12);
			if (ToString(num) == ",") {
				ObjSpriteList2D_SetSourceRect(obj, 224, 144 + 1, 239, 159 + 1); //176, 191 for period
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0 + 5, 16 + commaCount * 5, 16 + 5);
				ObjRender_SetX(obj, ObjRender_GetX(obj) + 6);
				commaCount ++;
			} else {
				ObjSpriteList2D_SetSourceRect(obj, num * 16, 144, (num + 1) * 16, 144 + 16);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0, 16 + commaCount * 5, 16);
			}
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}
task UpdatePower {
	let objPower = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objPower, guiPath);
	Obj_SetRenderPriority(objPower, 0.1);
	ObjSprite2D_SetSourceRect(objPower, 479, 26 * 3, 479 + 127, (26 * 4) - 1);
	ObjSprite2D_SetDestRect(objPower, 0, 0, 128, 26);
	ObjRender_SetScaleX(objPower, 0.75);
	ObjRender_SetScaleY(objPower, 0.75);
	ObjRender_SetX(objPower, 640 - 200);
	ObjRender_SetY(objPower, 225 - 46);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 225 - 46 + 3);
	ObjRender_SetColor(obj, 219, 127, 70); //221 111 42

	while (true) {
		//The definition of "Black magic fuckery"
		SetPlayerPower(GetCommonData("player_power", 0));
		let number = GetPlayerPower();
		if (number > 4) {
			SetCommonData("player_power", 4);
			SetPlayerPower(GetCommonData("player_power", 0));
			number = GetPlayerPower();
		}
		number = min(number, 4);
		let tempString = rtos("0.00", number);
		let listNum = [IntToString(tempString[0]), ".", IntToString(tempString[2]), IntToString(tempString[3])];
		listNum = listNum ~ ["/", "4", ".", "0", "0"];

		ObjSpriteList2D_ClearVertexCount(obj);
		ascent(i in 0 .. length(listNum)) {
			let num = listNum[i];
			ObjRender_SetX(obj, 640 - 20 - (length(listNum) - 1 - i) * 12);
			if (ToString(num) == ".") {
				ObjSpriteList2D_SetSourceRect(obj, 176, 144 + 1, 191, 159 + 1);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 16);
				ObjRender_SetX(obj, ObjRender_GetX(obj) + 1.5);
			} else if (ToString(num) == "/") {
				ObjSpriteList2D_SetSourceRect(obj, 160, 144, 175, 159);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 16);
			} else {
				ObjSpriteList2D_SetSourceRect(obj, atoi(num) * 16, 144, (atoi(num) + 1) * 16, 144 + 16);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 16);
			}
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}
task UpdatePoint {
	let objPoint = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objPoint, guiPath);
	Obj_SetRenderPriority(objPoint, 0.1);
	ObjSprite2D_SetSourceRect(objPoint, 479, 26 * 2, 479 + 127, (26 * 3) - 1);
	ObjSprite2D_SetDestRect(objPoint, 0, 0, 128, 26);
	ObjRender_SetScaleX(objPoint, 0.75);
	ObjRender_SetScaleY(objPoint, 0.75);
	ObjRender_SetX(objPoint, 640 - 200);
	ObjRender_SetY(objPoint, 225 - 21.5);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 225 - 22 + 2);
	ObjRender_SetColor(obj, 22, 181, 255); //64 92 255

	while (true) {
		let number = 0;
		if (GetCommonData("player_point", 0) > 50000000) {
			SetCommonData("player_point", 50000000); //50000000, because I feel this is balanced
		}
		number = GetCommonData("player_point", 0); 
		let listNum = NumberToArray(number, true);
		let commaCount = 0;

		ObjSpriteList2D_ClearVertexCount(obj);
		descent (i in 0 .. length(listNum)) {
			let num = listNum[i];
			ObjRender_SetX(obj, 640 - 20 - (length(listNum) - 1 - i) * 12);
			if (ToString(num) == ",") {
				ObjSpriteList2D_SetSourceRect(obj, 224, 144 + 1, 239, 159 + 1); //176, 191 for comma, current one is period
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0 + 5, 16 + commaCount * 5, 16 + 5);
				ObjRender_SetX(obj, ObjRender_GetX(obj) + 6);
				commaCount ++;
			} else {
				ObjSpriteList2D_SetSourceRect(obj, num * 16, 144, (num + 1) * 16, 144 + 16);
				ObjSpriteList2D_SetDestRect(obj, 0 + commaCount * 5, 0, 16 + commaCount * 5, 16);
			}
			ObjSpriteList2D_AddVertex(obj);
		}
		yield;
	}
}
task UpdatePlayerLife {
	let objLife = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objLife, guiPath);
	Obj_SetRenderPriority(objLife, 0.1);
	ObjSprite2D_SetSourceRect(objLife, 375 + 1, 26 * 2, 375 + 104, (26 * 3) - 1); //Plus 1 at 375 because some weird problem that a black line appear
	ObjSprite2D_SetDestRect(objLife, 0, 0, 104, 26);
	ObjRender_SetScaleX(objLife, 0.75);
	ObjRender_SetScaleY(objLife, 0.75);
	ObjRender_SetX(objLife, 640 - 212.5 - 7);
	ObjRender_SetY(objLife, 94);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, guiPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 94 + 2);
	ObjRender_SetScaleX(obj, 0.7);
	ObjRender_SetScaleY(obj, 0.7);

	while (true) {
		while (GetCommonData("player_life_piece", 0) >= 1) {
			SetCommonData("player_life_piece", GetCommonData("player_life_piece", 0) - 1);
			if (GetCommonData("player_life", 0) < GetCommonData("player_life_max", 8)) {
				SetCommonData("player_life", GetCommonData("player_life", 0) + 1);
			}
		}
		if (GetCommonData("player_life", 0) >= GetCommonData("player_life_max", 8)) {
			SetCommonData("player_life", GetCommonData("player_life_max", 8));
			SetCommonData("player_life_piece", 0);
		}

		let piece = GetCommonData("player_life_piece", 0);

		let number =  GetCommonData("player_life", 0);
		number = min(number, GetCommonData("player_life_max", 8));
		SetPlayerLife(number);

		let count = 0;

		ObjSpriteList2D_ClearVertexCount(obj);

		//First render current life
		ascent(i in 0 .. number) {
			let num = i;
			ObjRender_SetX(obj, 640 - 152 - (number - count) * -16);
			ObjSpriteList2D_SetSourceRect(obj, 727 + 1, 1, 750 - 1, 25);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24, 26);
			ObjSpriteList2D_AddVertex(obj);
			count ++;
		}
		//Render half life, quarter life, ...
		if (number < GetCommonData("player_life_max", 8)) {
			let pieceCount = GetCommonData("player_life_piece", 0);
			count ++;
			ObjRender_SetX(obj, 640 - 152 + (count) * 16);
			ObjSpriteList2D_SetSourceRect(obj, 609 + floor(pieceCount * 5) * 24 - pieceCount, 1, 630 + 1 + floor(pieceCount * 5) * 24 - pieceCount, 25);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24 + 1, 26);
			ObjSpriteList2D_AddVertex(obj);
		}
		//Render empty life
		ascent(i in 0 .. GetCommonData("player_life_max", 0) - 1 - number) {
			let num = i;
			ObjRender_SetX(obj, 640 - 152 - (count + 1) * -16);
			ObjSpriteList2D_SetSourceRect(obj, 609, 1, 630 + 1, 25);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24 + 1, 26);
			ObjSpriteList2D_AddVertex(obj);
			count ++;
		}

		yield;
	}
}
task UpdatePlayerSpell {
	let objSpell = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objSpell, guiPath);
	Obj_SetRenderPriority(objSpell, 0.1);
	ObjSprite2D_SetSourceRect(objSpell, 479, 0 + 1, 605, 25);
	ObjSprite2D_SetDestRect(objSpell, 0, 0, 128, 26);
	ObjRender_SetScaleX(objSpell, 0.75);
	ObjRender_SetScaleY(objSpell, 0.75);
	ObjRender_SetX(objSpell, 640 - 212.5 - 10);
	ObjRender_SetY(objSpell, 130);

	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, guiPath);
	Obj_SetRenderPriority(obj, 0.1);
	ObjRender_SetY(obj, 130 - 1);
	ObjRender_SetScaleX(obj, 0.7);
	ObjRender_SetScaleY(obj, 0.7);

	while (true) {
		while (GetCommonData("player_spell_piece", 0) >= 1) {
			SetCommonData("player_spell_piece", GetCommonData("player_spell_piece", 0) - 1);
			if (GetCommonData("player_spell", 0) < GetCommonData("player_spell_max", 8)) {
				SetCommonData("player_spell", GetCommonData("player_spell", 0) + 1);
			}
		}
		if (GetCommonData("player_spell", 0) >= GetCommonData("player_spell_max", 8)) {
			SetCommonData("player_spell", GetCommonData("player_spell_max", 8));
			SetCommonData("player_spell_piece", 0);
		}

		let piece = GetCommonData("player_spell_piece", 0);

		let number =  GetCommonData("player_spell", 0);
		number = min(number, GetCommonData("player_spell_max", 8));
		SetPlayerSpell(number);

		let count = 0;

		ObjSpriteList2D_ClearVertexCount(obj);

		//First render current spell
		ascent(i in 0 .. number) {
			let num = i;
			ObjRender_SetX(obj, 640 - 152 - (number - count) * -16);
			ObjSpriteList2D_SetSourceRect(obj, 727, 0 + 27, 750 - 1, 25 + 27);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24, 26);
			ObjSpriteList2D_AddVertex(obj);
			count ++;
		}
		//Render half spell, quarter spell, ...
		if (number < GetCommonData("player_spell_max", 8)) {
			let pieceCount = GetCommonData("player_spell_piece", 0);
			count ++;
			ObjRender_SetX(obj, 640 - 152 + (count) * 16);
			ObjSpriteList2D_SetSourceRect(obj, 608 + floor(pieceCount * 5) * 24 - pieceCount, 0 + 27, 630 + 2 + floor(pieceCount * 5) * 24 - pieceCount, 25 + 27);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24 + 2, 26);
			ObjSpriteList2D_AddVertex(obj);
		}
		//Render empty spell
		ascent(i in 0 .. GetCommonData("player_spell_max", 0) - 1 - number) {
			let num = i;
			ObjRender_SetX(obj, 640 - 152 - (count + 1) * -16);
			ObjSpriteList2D_SetSourceRect(obj, 608, 0 + 27, 630 + 1, 25 + 27);
			ObjSpriteList2D_SetDestRect(obj, 0, 0, 24 + 1, 26);
			ObjSpriteList2D_AddVertex(obj);
			count ++;
		}

		yield;
	}
}

task UpdateBossLife
{
	let active = false;
	
	let path = GetCurrentScriptDirectory() ~ "img/Default_System.png";

	let lastRemStep = -1;
	let lifeRateRender = 0;

	let objScene = ID_INVALID;
	loop
	{
		objScene = GetEnemyBossSceneObjectID();
		if(objScene != ID_INVALID)
		{
			if(!active){
				RenderCircle;
			}
		}
		yield;
	}


	task RenderCircle{
		lifeRateRender = 0;
		active = true;

		//Not actually a lifebar, but you have to render those green stars somewhere!
		let stars = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
		Obj_SetRenderPriority(stars,0.75);
		ObjPrim_SetTexture(stars, "script/main/img/system/lifebar.png");
		ObjSpriteList2D_SetSourceRect(stars,17,0,29,12);
		
		task updateStars(count){
			ObjSpriteList2D_ClearVertexCount(stars);
			ascent(i in 0..count){
				ObjSpriteList2D_SetDestRect(stars,0,0,12,12);
				ObjRender_SetPosition(stars,8+(i%6)*14,16+floor(i/6)*14,0);
				ObjSpriteList2D_AddVertex(stars);
			}
			ObjSpriteList2D_CloseVertex(stars);
		}
		CheckStarFade;
		
		//Sprite list for those little divider things
		let divisions = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
		Obj_SetRenderPriority(divisions,0.75);
		ObjPrim_SetTexture(divisions, "script/main/img/system/lifebar.png");
		ObjSpriteList2D_SetSourceRect(divisions,10,0,15,6);
		redrawDivisions;

		//Will be called again to update them when the lifebar is emptied
		task redrawDivisions{
			let listLifeDiv = [] ~ ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_LIFE_RATE_LIST);
			ObjSpriteList2D_ClearVertexCount(divisions);
			ascent(i in 0..length(listLifeDiv)-1){
				let angle = listLifeDiv[i]*360-90;
				ObjSpriteList2D_SetDestRect(divisions,-2,-4,3,4);
				ObjRender_SetPosition(divisions,cos(angle)*68,sin(angle)*68,0);
				ObjRender_SetAngleZ(divisions,angle+90);
				ObjSpriteList2D_AddVertex(divisions);
			}
			ObjSpriteList2D_CloseVertex(divisions);
		}

		//This is the actual lifebar
		let lifebar = ObjPrim_Create(OBJ_PRIMITIVE_2D);
		Obj_SetRenderPriority(lifebar,0.74);
		ObjPrim_SetTexture(lifebar, "script/main/img/system/lifebar.png");
		ObjPrim_SetPrimitiveType(lifebar,PRIMITIVE_TRIANGLESTRIP);
		ObjPrim_SetVertexCount(lifebar,62);
	
		//Two circles to make the empty part of the lifebar
		let circles = [];
		ascent(i in 0..2){
			circles = circles ~ [ObjPrim_Create(OBJ_PRIMITIVE_2D)];
		}
		
		ascent(i in 0..2){
			ObjPrim_SetTexture(circles[i], "script/main/img/system/lifebar.png");
			ObjPrim_SetPrimitiveType(circles[i],PRIMITIVE_TRIANGLESTRIP);
			ObjPrim_SetVertexCount(circles[i],62);
			Obj_SetRenderPriority(circles[i],0.74);
		}
		
		//Set up textures for all the circular parts
		ascent(iVert in 0..31)
		{
			let indexVert = iVert*2;
			ascent(i in 0..2){
				ObjPrim_SetVertexUVT(circles[i], indexVert + 0, 5, 0);
				ObjPrim_SetVertexUVT(circles[i], indexVert + 1, 9, 16);
			}
			ObjPrim_SetVertexUVT(lifebar, indexVert + 0, 0, 0);
			ObjPrim_SetVertexUVT(lifebar, indexVert + 1, 4, 16);
		}
		
		//Finalize the empty circles
		ascent(i in 0..31){
			ascent(j in 0..2){
				ascent(k in 0..2){
					ObjPrim_SetVertexPosition(circles[k],i*2+j,cos(i*12)*(60-j-k*3),sin(i*12)*(60-j-k*3),0);
				}
			}
		}

		//Keep updating things until the boss scene no longer exists
		while(objScene != ID_INVALID){
			let lifeTotalMax = ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_TOTAL_MAX_LIFE);
			let lifeTotal = ObjEnemyBossScene_GetInfo(objScene, INFO_ACTIVE_STEP_TOTAL_LIFE);
			let lifeRate = min(lifeTotal / lifeTotalMax, lifeRateRender);

			let countRemStep = ObjEnemyBossScene_GetInfo(objScene, INFO_REMAIN_STEP_COUNT);
			if(lastRemStep != countRemStep)
			{
				lifeRateRender = 0;
				redrawDivisions;
				updateStars(countRemStep);
			}

			//Move all to boss' position
			let boss = GetEnemyBossObjectID();
			if(length(boss) > 0){
				ascent(i in 0..2){
					ObjRender_SetPosition(circles[i],ObjMove_GetX(boss[0]),ObjMove_GetY(boss[0]),0);
				}
				ObjRender_SetPosition(lifebar,ObjMove_GetX(boss[0]),ObjMove_GetY(boss[0]),0);
				ObjRender_SetPosition(divisions,ObjMove_GetX(boss[0]),ObjMove_GetY(boss[0]),0);
			}

			//Redraw health bar
			let angle = 12*lifeRate;
			ascent(i in 0..31){
				let xpos = cos(-i*angle-90);
				let ypos = sin(-i*angle-90);
				ascent(j in 0..2){
					ObjPrim_SetVertexPosition(lifebar,i*2+j,xpos*(60-j*4),ypos*(60-j*4),0);
				}
			}
			
			lifeRateRender = min(lifeRateRender + 0.01, 1);
			lastRemStep = countRemStep;

			yield;
		}
		
		//Throw all the things away
		Obj_Delete(lifebar);
		Obj_Delete(divisions);
		Obj_Delete(stars);
		ascent(i in 0..2){
			Obj_Delete(circles[i]);
		}

		//And make sure the lifebar can actually appear again!!
		active = false;

		task CheckStarFade{
			let objPlayer = GetPlayerObjectID();
			while(!Obj_IsDeleted(stars)){
				if(ObjMove_GetX(objPlayer) < 100 && ObjMove_GetY(objPlayer) < 64){
					ObjRender_SetAlpha(stars,128);
					updateStars(ObjEnemyBossScene_GetInfo(objScene, INFO_REMAIN_STEP_COUNT));
					while(ObjMove_GetX(objPlayer) < 100 && ObjMove_GetY(objPlayer) < 64 && !Obj_IsDeleted(stars)){yield;}
					ObjRender_SetAlpha(stars,256);
					updateStars(ObjEnemyBossScene_GetInfo(objScene, INFO_REMAIN_STEP_COUNT));
				}
				yield;
			}
		}

	}
}

task UpdateBossTimer
{
	let timeout1 = ObjSound_Create;
	ObjSound_Load(timeout1,GetCurrentScriptDirectory() ~ "../snd/sfx/system_timeout1.wav");
	let timeout2 = ObjSound_Create;
	ObjSound_Load(timeout2,GetCurrentScriptDirectory() ~ "../snd/sfx/system_timeout2.wav");

	let active = false;
	let obj = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(obj, digitPath);
	Obj_SetRenderPriority(obj, 0.75);
	ObjRender_SetY(obj, 0);
	let count = 4;

	let objScene = ID_INVALID;
	CheckBossScene;

	task CheckBossScene{
		while(!Obj_IsDeleted(obj)){
			objScene = GetEnemyBossSceneObjectID();
			yield;
		}
	}

		let time;
		let sec = 0;
		active = true;
		//CheckSpell;
		CheckRemainingTime;
		CheckTimerFade;
		while(objScene != ID_INVALID){
			ObjSpriteList2D_ClearVertexCount(obj);
			time = ObjEnemyBossScene_GetInfo(objScene, INFO_TIMERF);
			sec = min(99.99,time/60);
			let listNum = DigitToArray(sec*100,count);
			ascent(i in 0 .. count-2){
				let num = listNum[i];
				ObjRender_SetX(obj, 164 + i * 12);
				ObjSpriteList2D_SetSourceRect(obj,  num * 16, 144, 1 + (num + 1) * 16, 160);
				ObjSpriteList2D_SetDestRect(obj, 0, 0, 16, 16);
				ObjSpriteList2D_AddVertex(obj);
			}
			ObjRender_SetX(obj,168+20);
			//ObjSpriteList2D_SetSourceRect(obj, 175, 0, 183, 26);
			ObjSpriteList2D_SetSourceRect(obj, 176, 145, 191, 160);
			ObjSpriteList2D_SetDestRect(obj, -3, 3, 12, 18);
			ObjSpriteList2D_AddVertex(obj);
			ascent(i in count-2 .. count){
				let num = listNum[i];
				ObjRender_SetX(obj, 175 + i*9);
				ObjSpriteList2D_SetSourceRect(obj,  num * 16, 144, 1 + (num + 1) * 16, 160);
				ObjSpriteList2D_SetDestRect(obj, 0, 6, 10, 16);
				ObjSpriteList2D_AddVertex(obj);
			}
			ObjSpriteList2D_CloseVertex(obj);
			yield;

		}
		active = false;
		ObjSpriteList2D_ClearVertexCount(obj);

		task CheckTimerFade{
			let objPlayer = GetPlayerObjectID();
			while(active){
				if(ObjMove_GetX(objPlayer) > 162 && ObjMove_GetX(objPlayer) < 222 && ObjMove_GetY(objPlayer) < 96){
					ObjRender_SetAlpha(obj,128);
					while(ObjMove_GetX(objPlayer) > 162 && ObjMove_GetX(objPlayer) < 222 && ObjMove_GetY(objPlayer) < 96 && active){yield;}
					ObjRender_SetAlpha(obj,256);
				}
				yield;
			}
		}
		//TODO: update this once we decide how to check if a spell is active
		/*task CheckSpell{
			while(active){
				while(!GetCommonData("SpellActive",false) && active){
					yield;
				}
				ascent(i in 0..35){
					ObjRender_SetY(obj,i);
					yield;
				}
				while(GetCommonData("SpellActive",false) && active){
					ObjRender_SetY(obj,35);
					yield;
				}
				descent(i in 0..35){
					ObjRender_SetY(obj,i);
					yield;
				}
			}
		}*/

		task CheckRemainingTime{
			while(objScene != ID_INVALID){
				yield;
				while(sec > 10 && active){
					yield;
				}
				ObjRender_SetColor(obj,256,128,128);
				while(sec <= 10 && sec >= 5 && active){
					if(sec%1 == 0){Beep;}
					yield;
				}
				ObjRender_SetColor(obj,256,64,64);
				while(sec <= 5 && sec > 0 && active){
					if(sec%1 == 0){Beep;}
					yield;
				}
				ObjRender_SetColor(obj,256,256,256);
			}
			
			task Beep{
				if(sec > 5){
					ObjSound_Play(timeout1);
					descent(i in 0..5){
						ObjRender_SetScaleXYZ(obj,1+i/20,1+i/20,0);
						yield;
					}
				}
				else{
					ObjSound_Play(timeout2);
					descent(i in 0..5){
						ObjRender_SetScaleXYZ(obj,1+i/10,1+i/10,0);
						yield;
					}
				}
			}
		}
}

task UpdateBossXPos (obj) {
	let objBossMark = ObjPrim_Create(OBJ_SPRITE_2D);
	ObjPrim_SetTexture(objBossMark, guiPath);
	Obj_SetRenderPriority(objBossMark, 0.1);
	ObjSprite2D_SetSourceRect(objBossMark, 683, 726, 746, 749); //The right one
	ObjSprite2D_SetDestRect(objBossMark, 0, 0, 64, 16);
	ObjRender_SetColor(objBossMark, 255, 0, 0);
	ObjRender_SetY(objBossMark, 480 - 16);
  ObjRender_SetAlpha(objBossMark, 170);
	while (GetEventType() != EV_END_BOSS_STEP) {
		if (Obj_IsDeleted(obj)) {
			ObjRender_SetAlpha(objBossMark, 0);
			return;
		}
		ObjRender_SetX(objBossMark, ObjMove_GetX(obj));
		yield;
	}
}
task UpdateCurrentFpsAndMs {
	let objFps = ObjText_Create();
	ObjText_SetFontType(objFps, "Russell Square Std");//GetCurrentScriptDirectory() ~ "system/russell-square.ttf");
	ObjText_SetFontSize(objFps, 15);
	ObjText_SetFontBold(objFps, true);
	ObjText_SetFontColorTop(objFps, 205, 205, 205);
	ObjText_SetFontColorBottom(objFps, 100, 100, 100);
	ObjText_SetFontBorderType(objFps, BORDER_FULL);
	ObjText_SetFontBorderColor(objFps, 0, 0, 0);
	ObjText_SetFontBorderWidth(objFps, 1);
	ObjText_SetHorizontalAlignment(objFps, ALIGNMENT_RIGHT);
	ObjText_SetMaxWidth(objFps, GetScreenWidth() - 8);
	Obj_SetRenderPriority(objFps, 1);
	ObjRender_SetX(objFps, 5);
	ObjRender_SetY(objFps, GetScreenHeight() - 16);

	let objMs = ObjText_Create();
	ObjText_SetFontType(objMs, "Russell Square Std");
	ObjText_SetFontSize(objMs, 15);
	ObjText_SetFontBold(objMs, true);
	ObjText_SetFontColorTop(objMs, 205, 205, 205);
	ObjText_SetFontColorBottom(objMs, 100, 100, 100);
	ObjText_SetFontBorderType(objMs, BORDER_FULL);
	ObjText_SetFontBorderColor(objMs, 0, 0, 0);
	ObjText_SetFontBorderWidth(objMs, 1);
	ObjText_SetHorizontalAlignment(objMs, ALIGNMENT_RIGHT);
	ObjText_SetMaxWidth(objMs, GetScreenWidth() - 8);
	Obj_SetRenderPriority(objMs, 1);
	ObjRender_SetX(objMs, 5);
	ObjRender_SetY(objMs, GetScreenHeight() - 30);

	//Option
	let smoothing = 1; //Can change this value, should be in option menu tho, minumum 1
	let fpsRate = 5; //For Fps only, can change in option menu too, in frame
	let maxMs = 0; //Do not change this value, seriously, because I don't know what this one do ...

	//Value that can't change
	let time = 0;
	let thisFrameTime = 0;
	let lastLoop = GetStageTime() - maxMs;
	let frameTime = maxMs; //Do not touch this
	let frameStart = GetStageTime(); //smooth value
	let tempFpsRate = 0;
	let listNum;

	let ms = 0;
	let fps = 0;

	while (true) {
		//Calculate fps and ms
		time = GetStageTime();
		thisFrameTime = time - lastLoop;
		frameTime += (thisFrameTime - frameTime) / smoothing;
		if (frameStart < lastLoop) {
			ms = frameTime;
		} else {
			ms = time - frameStart;
		}
		lastLoop = time;

		/*let time = GetStageTime();
		let ms = time - preTime;
		preTime = time;*/

		//Render fps and ms
		if (GetCurrentFps() <= fpsRate) {
			 tempFpsRate = 0;
		}
		if (tempFpsRate <= 0) {
			fps = min(1000 / frameTime, GetCurrentFps());
			tempFpsRate += fpsRate;
			ObjText_SetText(objFps, rtos("0.000", fps) ~ " fps");
		} else {
			tempFpsRate --;
		}
		ObjText_SetText(objMs, IntToString(ms) ~ " ms");
		yield;
	}
}
task UpdateReplayFps {
	//Too lazy to change comma here... As it not important...
	if (!IsReplay()) {
		return;
	}
	let objFps = ObjText_Create();
	ObjText_SetFontType(objFps, "Russell Square Std");//GetCurrentScriptDirectory() ~ "system/russell-square.ttf");
	ObjText_SetFontSize(objFps, 15);
	ObjText_SetFontBold(objFps, true);
	ObjText_SetFontColorTop(objFps, 205, 205, 205);
	ObjText_SetFontColorBottom(objFps, 100, 100, 100);
	ObjText_SetFontBorderType(objFps, BORDER_FULL);
	ObjText_SetFontBorderColor(objFps, 0, 0, 0);
	ObjText_SetFontBorderWidth(objFps, 1);
	ObjText_SetHorizontalAlignment(objFps, ALIGNMENT_LEFT);
	ObjText_SetMaxWidth(objFps, GetScreenWidth() - 8);
	Obj_SetRenderPriority(objFps, 1);
	ObjRender_SetX(objFps, 640 - 222.5);
	ObjRender_SetY(objFps, GetScreenHeight() - 16);

	while (true) {
		ObjText_SetText(objFps, IntToString(GetReplayFps()) ~ " fps");
		yield;
	}
}

function NumberToArray(let number, let haveComma) {
	let res = [];
	let str = IntToString(truncate(number));
	let count = 3 - length(str) % 3;
	ascent (i in 0..length(str)) {
		res = res ~ [str[i]];
		count ++;
		if (count % 3 == 0 && haveComma == true && i != length(str) - 1) {
			res = res ~ ",";
		}
	}
	return res;
}


function DigitToArray(let digit,let count)
{
	let res = [];
	digit = truncate(digit);

	loop
	{
		let tnum = truncate(digit % 10);
		digit /= 10;
		res = [tnum] ~ res;
		if(truncate(digit) == 0){break;}
	}

	loop(max(0, count - length(res)))
	{
		res = [0] ~ res;
	}

	return res;
}
#TouhouDanmakufu[Package]
#Title["Package"]
#Text["i.e the main menu"]

@Initialize {

	DisplayTitle;
}


@MainLoop {
  yield;
}

@Finalize {

}


//Constants! Please use those to refer to options!
let OPTION_MAIN = -1;
let OPTION_STARTGAME = 0;
let OPTION_EXTRA = 1;
let OPTION_PRACTICE = 2;
let OPTION_SPELLPRACTICE = 3;
let OPTION_REPLAY = 4;
let OPTION_PLAYERDATA = 5;
let OPTION_MUSICROOM = 6;
let OPTION_OPTIONS = 7; //lol
let OPTION_OMAKE = 8;
let OPTION_MANUAL = 9;
let OPTION_QUIT = 10;


task DisplayTitle{

	//Create all objects
	let dir = GetCurrentScriptDirectory();
	let titleImg = ObjPrim_Create(OBJ_SPRITE_2D);
	Obj_SetRenderPriorityI(titleImg,20);
	ObjPrim_SetTexture(titleImg, dir ~ "/system/menus2.png");
	ObjSprite2D_SetSourceRect(titleImg, 0, 0, 1000, 750);
 	ObjSprite2D_SetDestRect(titleImg, 0, 0, 1000, 750);
	ObjRender_SetScaleX(titleImg, 640 / 1000);
	ObjRender_SetScaleY(titleImg, 480 / 750);

	let objWheelOverlap = ObjPrim_Create(OBJ_SPRITE_2D);
	Obj_SetRenderPriorityI(objWheelOverlap, 23);
	ObjPrim_SetTexture(objWheelOverlap, dir ~ "/system/spokes.png");
	ObjSprite2D_SetSourceRect(objWheelOverlap, 188, 46, 843, 701);
	ObjSprite2D_SetDestCenter(objWheelOverlap);
	ObjRender_SetScaleXYZ(objWheelOverlap,0.65,0.65,1);
	ObjRender_SetY(objWheelOverlap,340);
	
	let objWheel = ObjPrim_Create(OBJ_SPRITE_2D);
	Obj_SetRenderPriorityI(objWheel, 21);
	ObjPrim_SetTexture(objWheel, dir ~ "/system/spokes.png");
	ObjSprite2D_SetSourceRect(objWheel, 188, 46, 843, 701);
	ObjSprite2D_SetDestCenter(objWheel);
	ObjRender_SetScaleXYZ(objWheel,0.65,0.65,1);
	ObjRender_SetY(objWheel,340);
	ObjRender_SetAlpha(objWheel,0);

	let objWheelOptions = ObjPrim_Create(OBJ_SPRITE_LIST_2D);
	ObjPrim_SetTexture(objWheelOptions, dir ~ "/system/MenuOp.png");
	Obj_SetRenderPriorityI(objWheelOptions, 22);

	//Launch the wheel animation intro
	WheelFade(objWheelOverlap,objWheel);
	
	//tracks currently selected menu
	let currMenu = OPTION_MAIN;

	//Make sure to display the game title!!
	TitleGraphics;

	wait(100);
	//Wheel angle handling stuff you probably shouldn't mess with
	let destAngle = 0;
	let currAngle = 0;

	//Also used for tracking the wheel options' position. Fragile!
	let position = 0;

	//Start actually responding to controls
	MainMenu;
	wheelSpin;

	task TitleGraphics{
		let title = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(title,GetCurrentScriptDirectory() ~ "./system/title.png");
		ObjSprite2D_SetSourceRect(title,0,0,722,477);
		ObjSprite2D_SetDestRect(title,0,0,722,477);
		ObjRender_SetScaleXYZ(title,0.5,0.5,0);

		
		let reimu = ObjPrim_Create(OBJ_SPRITE_2D);
		ObjPrim_SetTexture(reimu,GetCurrentScriptDirectory() ~ "./system/ReimuTitle.png");
		ObjSprite2D_SetSourceRect(reimu,0,0,412,592);
		ObjSprite2D_SetDestCenter(reimu);
		ObjRender_SetScaleXYZ(reimu,0.6,0.6,0);

		descent(i in 0..96){
			ObjRender_SetAlpha(title,256-i*3);
			ObjRender_SetAlpha(reimu,256-i*3);
			ObjRender_SetPosition(title,30+i*(i/30),-20,0);
			ObjRender_SetPosition(reimu,484,260+i*(i/50),0);
			yield;
		}
		
		loop{
			while(currMenu == OPTION_MAIN){yield;}
			ascent(i in 0..32){
				if(currMenu == OPTION_MAIN){break;}
				ObjRender_SetAlpha(title,256-i*9);
				ObjRender_SetAlpha(reimu,256-i*9);
				ObjRender_SetPosition(title,30-i*(i/10),-20,0);
				ObjRender_SetPosition(reimu,484,260+i*(i/50),0);
				yield;
			}
			while(currMenu != OPTION_MAIN){yield;}
			descent(i in 0..32){
				if(currMenu != OPTION_MAIN){break;}
				ObjRender_SetAlpha(title,256-i*9);
				ObjRender_SetAlpha(reimu,256-i*9);
				ObjRender_SetPosition(title,30-i*(i/30),-20,0);
				ObjRender_SetPosition(reimu,484,260+i*(i/50),0);
				yield;
			}
		}
	}

	task MainMenu{
		
		//Currently selected option
		let selected = 0;
		fadeWheel;
		yield;
		redrawMainOptions;

		//Listen to controls
		while(currMenu == OPTION_MAIN){
			//Actual actions
			if (GetVirtualKeyState(VK_OK) == KEY_PUSH) {
				alternative(selected)
				case(OPTION_QUIT){
					ClosePackage();
				}
				case(OPTION_STARTGAME){
					currMenu = OPTION_STARTGAME;
					fadeWheel;
					DifficultyMenu;
				}
			}
			
			//Movement
			if (GetVirtualKeyState(VK_DOWN) == KEY_PUSH) {
				selected = (selected + 1)%11;
				position++;
				destAngle -= 45;
				redrawMainOptions;
			}
			if (GetVirtualKeyState(VK_UP) == KEY_PUSH) {
				selected = (selected - 1)%11;
				position--;
				destAngle += 45;
				redrawMainOptions;
			}
			yield;
		}

		task redrawMainOptions{
			ObjSpriteList2D_ClearVertexCount(objWheelOptions);
			ObjRender_SetPosition(objWheelOptions,0,0,0);
			ascent(i in -4..4){
				let unselectOffset = 500;
				if(i == 0){unselectOffset = 0;}
				ObjRender_SetAngleZ(objWheelOptions,i*45 + position*45);
				i = (i+selected)%11;
				ObjSpriteList2D_SetSourceRect(objWheelOptions,unselectOffset,i*57,unselectOffset+300,(i+1)*57);
				ObjSpriteList2D_SetDestRect(objWheelOptions,80,-14,210,14);
				ObjSpriteList2D_AddVertex(objWheelOptions);
			}
			ObjSpriteList2D_CloseVertex(objWheelOptions);
			ObjRender_SetPosition(objWheelOptions,10,340,0);
		}
	}

	task DifficultyMenu{
		//Currently selected option
		let selected = 1;

		//Angle of wheel as of when entering this menu
		let origAngle = destAngle;

		//Position of wheel as of when entering this menu
		let origPosition = position;

		//Create the menu objects
		//512x155
		let options = [0,0,0,0];
		ascent(i in 0..4){
			let option = ObjPrim_Create(OBJ_SPRITE_2D);
			ObjPrim_SetTexture(option,dir ~ "system/difficulty.png");
			ObjSprite2D_SetSourceRect(option,512,i*160,1024,(i+1)*160);
			ObjSprite2D_SetDestCenter(option);
			ObjRender_SetScaleXYZ(option,0.9,0.9,1);
			ObjRender_SetPosition(option,420,500,1);
			options[i] = option;
		}

		let currPos = 40;
		let destPos = 40;
		moveOptions;
		SelectOption;
		
		wait(5);

		//Listen to controls
		while(currMenu == OPTION_STARTGAME){
			//Actual actions
			//if (GetVirtualKeyState(VK_OK) == KEY_PUSH) {
				
			//}
			if (GetVirtualKeyState(VK_CANCEL) == KEY_PUSH) {
				destAngle = origAngle;
				position = origPosition;
				DeleteOptions;
				currMenu = OPTION_MAIN;
				fadeWheel;
				MainMenu;
			}
			
			//Movement
			if (GetVirtualKeyState(VK_DOWN) == KEY_PUSH) {
				selected = (selected + 1)%4;
				SelectOption;
				destAngle -= 45;
			}
			if (GetVirtualKeyState(VK_UP) == KEY_PUSH) {
				selected = (selected - 1)%4;
				SelectOption;
				destAngle += 45;
			}
			yield;
		}

		task SelectOption{
			ascent(i in 0..4){
				ObjSprite2D_SetSourceRect(options[i],512,i*160,1024,(i+1)*160);
			}
			ObjSprite2D_SetSourceRect(options[selected],0,selected*160,512,(selected+1)*160);
			
			destPos = 240-selected*200;
		}

		task moveOptions{
			moveOtherOptions;
			while(!Obj_IsDeleted(options[0])){
				currPos = ObjRender_GetY(options[0]);
				if(currPos != destPos){
					let displace = (destPos - currPos)/7;
					if(absolute(displace) > 0.01){
						ObjRender_SetY(options[0],ObjRender_GetY(options[0])+displace);
					}
					else{
						ObjRender_SetY(options[0],destPos);
					}
				}
				yield;
			}

			task moveOtherOptions{
				while(!Obj_IsDeleted(options[0])){
					ascent(i in 1..4){
						ObjRender_SetY(options[i],ObjRender_GetY(options[0])+i*200);
					}
					yield;
				}
			}

		}
		

		task DeleteOptions{
			descent(i in 0..32){
				ascent(j in 0..4){
					ObjRender_SetAlpha(options[j],i*4);
				}
				yield;
			}
			ascent(i in 0..4){
				Obj_Delete(options[i]);
			}
		}
	}


	//Makes the wheel spin depending on the option selected
	task wheelSpin{
		optionsSpin;
		ObjRender_SetAngleZ(objWheel,0);
		loop{
			currAngle = ObjRender_GetAngleZ(objWheel);
			if(currAngle != destAngle){
				let displace = (destAngle - currAngle)/7;
				if(absolute(displace) > 0.01){
					ObjRender_SetAngleZ(objWheel,ObjRender_GetAngleZ(objWheel)+displace);
				}
				else{
					ObjRender_SetAngleZ(objWheel,destAngle);
				}
			}
			yield;
		}

		task optionsSpin{
			loop{
				ObjRender_SetAngleZ(objWheelOverlap,ObjRender_GetAngleZ(objWheel));
				ObjRender_SetAngleZ(objWheelOptions,ObjRender_GetAngleZ(objWheel));
				yield;
			}
		}
	}

	let cancelFade;

	task fadeWheel{
		cancelFade = true;
		yield;
		cancelFade = false;
		if(currMenu == OPTION_MAIN){
			descent(i in 0..33){
				if(cancelFade){break;}
				ObjRender_SetAlpha(objWheelOverlap,i*8);
				yield;
			}
		}
		else{
			ascent(i in 0..33){
				if(cancelFade){break;}
				ObjRender_SetAlpha(objWheelOverlap,i*8);
				yield;
			}
		}
	}
}


//Wheel intro task
task WheelFade(objFake,objReal){
	MoveFromSide;
	MaxSpeedSpin;
	FadeIn;

	//Moving-from-left part
	task MoveFromSide{
		descent(i in 0..60){
			ObjRender_SetX(objFake,10-i);
			ObjRender_SetX(objReal,10-i);
			yield;
		}
	}
	
	//Spinning part
	task MaxSpeedSpin{
		//offsets so it lands precisely on Game Start at the end of the spin
		ObjRender_SetAngleZ(objFake,125);
		ObjRender_SetAngleZ(objReal,125);

		let spd = 10;
		PleaseSlowDown;

		loop(90){
			ObjRender_SetAngleZ(objFake,ObjRender_GetAngleZ(objFake)+spd);
			ObjRender_SetAngleZ(objReal,ObjRender_GetAngleZ(objReal)+spd);
			yield;
		}
		task PleaseSlowDown{
			wait(30);
			descent(i in 0..60){
				spd = i/6;
				yield;
			}
		}
	}

	task FadeIn{
		wait(30);
		ascent(i in 0..65){
			ObjRender_SetAlpha(objReal,i*4);
			yield;
		}
		ObjRender_SetAlpha(objFake,0);
	}
}

function wait(n){
	loop(n){yield;}
}